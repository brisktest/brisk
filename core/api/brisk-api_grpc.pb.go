// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.3
// source: api/brisk-api.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Splitting_SplitForProject_FullMethodName = "/api.Splitting/SplitForProject"
)

// SplittingClient is the client API for Splitting service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SplittingClient interface {
	SplitForProject(ctx context.Context, in *SplitRequest, opts ...grpc.CallOption) (*SplitResponse, error)
}

type splittingClient struct {
	cc grpc.ClientConnInterface
}

func NewSplittingClient(cc grpc.ClientConnInterface) SplittingClient {
	return &splittingClient{cc}
}

func (c *splittingClient) SplitForProject(ctx context.Context, in *SplitRequest, opts ...grpc.CallOption) (*SplitResponse, error) {
	out := new(SplitResponse)
	err := c.cc.Invoke(ctx, Splitting_SplitForProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SplittingServer is the server API for Splitting service.
// All implementations must embed UnimplementedSplittingServer
// for forward compatibility
type SplittingServer interface {
	SplitForProject(context.Context, *SplitRequest) (*SplitResponse, error)
	mustEmbedUnimplementedSplittingServer()
}

// UnimplementedSplittingServer must be embedded to have forward compatible implementations.
type UnimplementedSplittingServer struct {
}

func (UnimplementedSplittingServer) SplitForProject(context.Context, *SplitRequest) (*SplitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SplitForProject not implemented")
}
func (UnimplementedSplittingServer) mustEmbedUnimplementedSplittingServer() {}

// UnsafeSplittingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SplittingServer will
// result in compilation errors.
type UnsafeSplittingServer interface {
	mustEmbedUnimplementedSplittingServer()
}

func RegisterSplittingServer(s grpc.ServiceRegistrar, srv SplittingServer) {
	s.RegisterService(&Splitting_ServiceDesc, srv)
}

func _Splitting_SplitForProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SplitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SplittingServer).SplitForProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Splitting_SplitForProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SplittingServer).SplitForProject(ctx, req.(*SplitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Splitting_ServiceDesc is the grpc.ServiceDesc for Splitting service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Splitting_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Splitting",
	HandlerType: (*SplittingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SplitForProject",
			Handler:    _Splitting_SplitForProject_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/brisk-api.proto",
}

const (
	Infra_RegisterMachine_FullMethodName   = "/api.Infra/RegisterMachine"
	Infra_DeRegisterMachine_FullMethodName = "/api.Infra/DeRegisterMachine"
	Infra_DrainMachine_FullMethodName      = "/api.Infra/DrainMachine"
)

// InfraClient is the client API for Infra service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InfraClient interface {
	RegisterMachine(ctx context.Context, in *MachineReq, opts ...grpc.CallOption) (*MachineResponse, error)
	DeRegisterMachine(ctx context.Context, in *MachineReq, opts ...grpc.CallOption) (*MachineResponse, error)
	DrainMachine(ctx context.Context, in *MachineReq, opts ...grpc.CallOption) (*MachineResponse, error)
}

type infraClient struct {
	cc grpc.ClientConnInterface
}

func NewInfraClient(cc grpc.ClientConnInterface) InfraClient {
	return &infraClient{cc}
}

func (c *infraClient) RegisterMachine(ctx context.Context, in *MachineReq, opts ...grpc.CallOption) (*MachineResponse, error) {
	out := new(MachineResponse)
	err := c.cc.Invoke(ctx, Infra_RegisterMachine_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraClient) DeRegisterMachine(ctx context.Context, in *MachineReq, opts ...grpc.CallOption) (*MachineResponse, error) {
	out := new(MachineResponse)
	err := c.cc.Invoke(ctx, Infra_DeRegisterMachine_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infraClient) DrainMachine(ctx context.Context, in *MachineReq, opts ...grpc.CallOption) (*MachineResponse, error) {
	out := new(MachineResponse)
	err := c.cc.Invoke(ctx, Infra_DrainMachine_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfraServer is the server API for Infra service.
// All implementations must embed UnimplementedInfraServer
// for forward compatibility
type InfraServer interface {
	RegisterMachine(context.Context, *MachineReq) (*MachineResponse, error)
	DeRegisterMachine(context.Context, *MachineReq) (*MachineResponse, error)
	DrainMachine(context.Context, *MachineReq) (*MachineResponse, error)
	mustEmbedUnimplementedInfraServer()
}

// UnimplementedInfraServer must be embedded to have forward compatible implementations.
type UnimplementedInfraServer struct {
}

func (UnimplementedInfraServer) RegisterMachine(context.Context, *MachineReq) (*MachineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterMachine not implemented")
}
func (UnimplementedInfraServer) DeRegisterMachine(context.Context, *MachineReq) (*MachineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeRegisterMachine not implemented")
}
func (UnimplementedInfraServer) DrainMachine(context.Context, *MachineReq) (*MachineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DrainMachine not implemented")
}
func (UnimplementedInfraServer) mustEmbedUnimplementedInfraServer() {}

// UnsafeInfraServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InfraServer will
// result in compilation errors.
type UnsafeInfraServer interface {
	mustEmbedUnimplementedInfraServer()
}

func RegisterInfraServer(s grpc.ServiceRegistrar, srv InfraServer) {
	s.RegisterService(&Infra_ServiceDesc, srv)
}

func _Infra_RegisterMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MachineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraServer).RegisterMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Infra_RegisterMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraServer).RegisterMachine(ctx, req.(*MachineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Infra_DeRegisterMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MachineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraServer).DeRegisterMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Infra_DeRegisterMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraServer).DeRegisterMachine(ctx, req.(*MachineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Infra_DrainMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MachineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfraServer).DrainMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Infra_DrainMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfraServer).DrainMachine(ctx, req.(*MachineReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Infra_ServiceDesc is the grpc.ServiceDesc for Infra service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Infra_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Infra",
	HandlerType: (*InfraServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterMachine",
			Handler:    _Infra_RegisterMachine_Handler,
		},
		{
			MethodName: "DeRegisterMachine",
			Handler:    _Infra_DeRegisterMachine_Handler,
		},
		{
			MethodName: "DrainMachine",
			Handler:    _Infra_DrainMachine_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/brisk-api.proto",
}

const (
	Users_Login_FullMethodName = "/api.Users/Login"
)

// UsersClient is the client API for Users service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UsersClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (Users_LoginClient, error)
}

type usersClient struct {
	cc grpc.ClientConnInterface
}

func NewUsersClient(cc grpc.ClientConnInterface) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (Users_LoginClient, error) {
	stream, err := c.cc.NewStream(ctx, &Users_ServiceDesc.Streams[0], Users_Login_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &usersLoginClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Users_LoginClient interface {
	Recv() (*LoginResponse, error)
	grpc.ClientStream
}

type usersLoginClient struct {
	grpc.ClientStream
}

func (x *usersLoginClient) Recv() (*LoginResponse, error) {
	m := new(LoginResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// UsersServer is the server API for Users service.
// All implementations must embed UnimplementedUsersServer
// for forward compatibility
type UsersServer interface {
	Login(*LoginRequest, Users_LoginServer) error
	mustEmbedUnimplementedUsersServer()
}

// UnimplementedUsersServer must be embedded to have forward compatible implementations.
type UnimplementedUsersServer struct {
}

func (UnimplementedUsersServer) Login(*LoginRequest, Users_LoginServer) error {
	return status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUsersServer) mustEmbedUnimplementedUsersServer() {}

// UnsafeUsersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UsersServer will
// result in compilation errors.
type UnsafeUsersServer interface {
	mustEmbedUnimplementedUsersServer()
}

func RegisterUsersServer(s grpc.ServiceRegistrar, srv UsersServer) {
	s.RegisterService(&Users_ServiceDesc, srv)
}

func _Users_Login_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LoginRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).Login(m, &usersLoginServer{stream})
}

type Users_LoginServer interface {
	Send(*LoginResponse) error
	grpc.ServerStream
}

type usersLoginServer struct {
	grpc.ServerStream
}

func (x *usersLoginServer) Send(m *LoginResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Users_ServiceDesc is the grpc.ServiceDesc for Users service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Users_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Users",
	HandlerType: (*UsersServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Login",
			Handler:       _Users_Login_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/brisk-api.proto",
}

const (
	Projects_LogRun_FullMethodName                         = "/api.Projects/LogRun"
	Projects_FinishRun_FullMethodName                      = "/api.Projects/FinishRun"
	Projects_GetProject_FullMethodName                     = "/api.Projects/GetProject"
	Projects_GetWorkersForProject_FullMethodName           = "/api.Projects/GetWorkersForProject"
	Projects_GetSuperForProject_FullMethodName             = "/api.Projects/GetSuperForProject"
	Projects_GetAdditionalWorkersForProject_FullMethodName = "/api.Projects/GetAdditionalWorkersForProject"
	Projects_ClearWorkersForProject_FullMethodName         = "/api.Projects/ClearWorkersForProject"
	Projects_DeRegisterWorkers_FullMethodName              = "/api.Projects/DeRegisterWorkers"
	Projects_InitProject_FullMethodName                    = "/api.Projects/InitProject"
	Projects_GetAllProjects_FullMethodName                 = "/api.Projects/GetAllProjects"
)

// ProjectsClient is the client API for Projects service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectsClient interface {
	LogRun(ctx context.Context, in *LogRunReq, opts ...grpc.CallOption) (*LogRunResp, error)
	FinishRun(ctx context.Context, in *FinishRunRequest, opts ...grpc.CallOption) (*FinishRunResponse, error)
	GetProject(ctx context.Context, in *GetProjectReq, opts ...grpc.CallOption) (*GetProjectResp, error)
	// Get workers to run against
	GetWorkersForProject(ctx context.Context, in *GetWorkersReq, opts ...grpc.CallOption) (*GetWorkersResp, error)
	GetSuperForProject(ctx context.Context, in *GetSuperReq, opts ...grpc.CallOption) (*GetSuperResp, error)
	// used when one of our workers fails
	GetAdditionalWorkersForProject(ctx context.Context, in *GetWorkersReq, opts ...grpc.CallOption) (*GetWorkersResp, error)
	ClearWorkersForProject(ctx context.Context, in *ClearWorkersReq, opts ...grpc.CallOption) (*ClearWorkersResp, error)
	DeRegisterWorkers(ctx context.Context, in *DeRegisterWorkersReq, opts ...grpc.CallOption) (*DeRegisterWorkersResp, error)
	InitProject(ctx context.Context, in *InitProjectReq, opts ...grpc.CallOption) (*InitProjectResp, error)
	GetAllProjects(ctx context.Context, in *GetAllProjectsReq, opts ...grpc.CallOption) (*GetAllProjectsResp, error)
}

type projectsClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectsClient(cc grpc.ClientConnInterface) ProjectsClient {
	return &projectsClient{cc}
}

func (c *projectsClient) LogRun(ctx context.Context, in *LogRunReq, opts ...grpc.CallOption) (*LogRunResp, error) {
	out := new(LogRunResp)
	err := c.cc.Invoke(ctx, Projects_LogRun_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) FinishRun(ctx context.Context, in *FinishRunRequest, opts ...grpc.CallOption) (*FinishRunResponse, error) {
	out := new(FinishRunResponse)
	err := c.cc.Invoke(ctx, Projects_FinishRun_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) GetProject(ctx context.Context, in *GetProjectReq, opts ...grpc.CallOption) (*GetProjectResp, error) {
	out := new(GetProjectResp)
	err := c.cc.Invoke(ctx, Projects_GetProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) GetWorkersForProject(ctx context.Context, in *GetWorkersReq, opts ...grpc.CallOption) (*GetWorkersResp, error) {
	out := new(GetWorkersResp)
	err := c.cc.Invoke(ctx, Projects_GetWorkersForProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) GetSuperForProject(ctx context.Context, in *GetSuperReq, opts ...grpc.CallOption) (*GetSuperResp, error) {
	out := new(GetSuperResp)
	err := c.cc.Invoke(ctx, Projects_GetSuperForProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) GetAdditionalWorkersForProject(ctx context.Context, in *GetWorkersReq, opts ...grpc.CallOption) (*GetWorkersResp, error) {
	out := new(GetWorkersResp)
	err := c.cc.Invoke(ctx, Projects_GetAdditionalWorkersForProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) ClearWorkersForProject(ctx context.Context, in *ClearWorkersReq, opts ...grpc.CallOption) (*ClearWorkersResp, error) {
	out := new(ClearWorkersResp)
	err := c.cc.Invoke(ctx, Projects_ClearWorkersForProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) DeRegisterWorkers(ctx context.Context, in *DeRegisterWorkersReq, opts ...grpc.CallOption) (*DeRegisterWorkersResp, error) {
	out := new(DeRegisterWorkersResp)
	err := c.cc.Invoke(ctx, Projects_DeRegisterWorkers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) InitProject(ctx context.Context, in *InitProjectReq, opts ...grpc.CallOption) (*InitProjectResp, error) {
	out := new(InitProjectResp)
	err := c.cc.Invoke(ctx, Projects_InitProject_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) GetAllProjects(ctx context.Context, in *GetAllProjectsReq, opts ...grpc.CallOption) (*GetAllProjectsResp, error) {
	out := new(GetAllProjectsResp)
	err := c.cc.Invoke(ctx, Projects_GetAllProjects_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectsServer is the server API for Projects service.
// All implementations must embed UnimplementedProjectsServer
// for forward compatibility
type ProjectsServer interface {
	LogRun(context.Context, *LogRunReq) (*LogRunResp, error)
	FinishRun(context.Context, *FinishRunRequest) (*FinishRunResponse, error)
	GetProject(context.Context, *GetProjectReq) (*GetProjectResp, error)
	// Get workers to run against
	GetWorkersForProject(context.Context, *GetWorkersReq) (*GetWorkersResp, error)
	GetSuperForProject(context.Context, *GetSuperReq) (*GetSuperResp, error)
	// used when one of our workers fails
	GetAdditionalWorkersForProject(context.Context, *GetWorkersReq) (*GetWorkersResp, error)
	ClearWorkersForProject(context.Context, *ClearWorkersReq) (*ClearWorkersResp, error)
	DeRegisterWorkers(context.Context, *DeRegisterWorkersReq) (*DeRegisterWorkersResp, error)
	InitProject(context.Context, *InitProjectReq) (*InitProjectResp, error)
	GetAllProjects(context.Context, *GetAllProjectsReq) (*GetAllProjectsResp, error)
	mustEmbedUnimplementedProjectsServer()
}

// UnimplementedProjectsServer must be embedded to have forward compatible implementations.
type UnimplementedProjectsServer struct {
}

func (UnimplementedProjectsServer) LogRun(context.Context, *LogRunReq) (*LogRunResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogRun not implemented")
}
func (UnimplementedProjectsServer) FinishRun(context.Context, *FinishRunRequest) (*FinishRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishRun not implemented")
}
func (UnimplementedProjectsServer) GetProject(context.Context, *GetProjectReq) (*GetProjectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProject not implemented")
}
func (UnimplementedProjectsServer) GetWorkersForProject(context.Context, *GetWorkersReq) (*GetWorkersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkersForProject not implemented")
}
func (UnimplementedProjectsServer) GetSuperForProject(context.Context, *GetSuperReq) (*GetSuperResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSuperForProject not implemented")
}
func (UnimplementedProjectsServer) GetAdditionalWorkersForProject(context.Context, *GetWorkersReq) (*GetWorkersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdditionalWorkersForProject not implemented")
}
func (UnimplementedProjectsServer) ClearWorkersForProject(context.Context, *ClearWorkersReq) (*ClearWorkersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearWorkersForProject not implemented")
}
func (UnimplementedProjectsServer) DeRegisterWorkers(context.Context, *DeRegisterWorkersReq) (*DeRegisterWorkersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeRegisterWorkers not implemented")
}
func (UnimplementedProjectsServer) InitProject(context.Context, *InitProjectReq) (*InitProjectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitProject not implemented")
}
func (UnimplementedProjectsServer) GetAllProjects(context.Context, *GetAllProjectsReq) (*GetAllProjectsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllProjects not implemented")
}
func (UnimplementedProjectsServer) mustEmbedUnimplementedProjectsServer() {}

// UnsafeProjectsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectsServer will
// result in compilation errors.
type UnsafeProjectsServer interface {
	mustEmbedUnimplementedProjectsServer()
}

func RegisterProjectsServer(s grpc.ServiceRegistrar, srv ProjectsServer) {
	s.RegisterService(&Projects_ServiceDesc, srv)
}

func _Projects_LogRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRunReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).LogRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_LogRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).LogRun(ctx, req.(*LogRunReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_FinishRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).FinishRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_FinishRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).FinishRun(ctx, req.(*FinishRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_GetProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).GetProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_GetProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).GetProject(ctx, req.(*GetProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_GetWorkersForProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).GetWorkersForProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_GetWorkersForProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).GetWorkersForProject(ctx, req.(*GetWorkersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_GetSuperForProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuperReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).GetSuperForProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_GetSuperForProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).GetSuperForProject(ctx, req.(*GetSuperReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_GetAdditionalWorkersForProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).GetAdditionalWorkersForProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_GetAdditionalWorkersForProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).GetAdditionalWorkersForProject(ctx, req.(*GetWorkersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_ClearWorkersForProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearWorkersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).ClearWorkersForProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_ClearWorkersForProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).ClearWorkersForProject(ctx, req.(*ClearWorkersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_DeRegisterWorkers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeRegisterWorkersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).DeRegisterWorkers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_DeRegisterWorkers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).DeRegisterWorkers(ctx, req.(*DeRegisterWorkersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_InitProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).InitProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_InitProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).InitProject(ctx, req.(*InitProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_GetAllProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllProjectsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).GetAllProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_GetAllProjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).GetAllProjects(ctx, req.(*GetAllProjectsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Projects_ServiceDesc is the grpc.ServiceDesc for Projects service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Projects_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Projects",
	HandlerType: (*ProjectsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LogRun",
			Handler:    _Projects_LogRun_Handler,
		},
		{
			MethodName: "FinishRun",
			Handler:    _Projects_FinishRun_Handler,
		},
		{
			MethodName: "GetProject",
			Handler:    _Projects_GetProject_Handler,
		},
		{
			MethodName: "GetWorkersForProject",
			Handler:    _Projects_GetWorkersForProject_Handler,
		},
		{
			MethodName: "GetSuperForProject",
			Handler:    _Projects_GetSuperForProject_Handler,
		},
		{
			MethodName: "GetAdditionalWorkersForProject",
			Handler:    _Projects_GetAdditionalWorkersForProject_Handler,
		},
		{
			MethodName: "ClearWorkersForProject",
			Handler:    _Projects_ClearWorkersForProject_Handler,
		},
		{
			MethodName: "DeRegisterWorkers",
			Handler:    _Projects_DeRegisterWorkers_Handler,
		},
		{
			MethodName: "InitProject",
			Handler:    _Projects_InitProject_Handler,
		},
		{
			MethodName: "GetAllProjects",
			Handler:    _Projects_GetAllProjects_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/brisk-api.proto",
}

const (
	Workers_Finished_FullMethodName                = "/api.Workers/Finished"
	Workers_BuildCommandsRun_FullMethodName        = "/api.Workers/BuildCommandsRun"
	Workers_Register_FullMethodName                = "/api.Workers/Register"
	Workers_DeRegister_FullMethodName              = "/api.Workers/DeRegister"
	Workers_GetRecentlyDeregistered_FullMethodName = "/api.Workers/GetRecentlyDeregistered"
)

// WorkersClient is the client API for Workers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WorkersClient interface {
	Finished(ctx context.Context, in *WorkerReq, opts ...grpc.CallOption) (*WorkerResponse, error)
	BuildCommandsRun(ctx context.Context, in *CommandsRunReq, opts ...grpc.CallOption) (*WorkerResponse, error)
	Register(ctx context.Context, in *WorkerRegReq, opts ...grpc.CallOption) (*WorkerResponse, error)
	DeRegister(ctx context.Context, in *WorkerReq, opts ...grpc.CallOption) (*WorkerResponse, error)
	GetRecentlyDeregistered(ctx context.Context, in *WorkersReq, opts ...grpc.CallOption) (*WorkersResp, error)
}

type workersClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkersClient(cc grpc.ClientConnInterface) WorkersClient {
	return &workersClient{cc}
}

func (c *workersClient) Finished(ctx context.Context, in *WorkerReq, opts ...grpc.CallOption) (*WorkerResponse, error) {
	out := new(WorkerResponse)
	err := c.cc.Invoke(ctx, Workers_Finished_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workersClient) BuildCommandsRun(ctx context.Context, in *CommandsRunReq, opts ...grpc.CallOption) (*WorkerResponse, error) {
	out := new(WorkerResponse)
	err := c.cc.Invoke(ctx, Workers_BuildCommandsRun_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workersClient) Register(ctx context.Context, in *WorkerRegReq, opts ...grpc.CallOption) (*WorkerResponse, error) {
	out := new(WorkerResponse)
	err := c.cc.Invoke(ctx, Workers_Register_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workersClient) DeRegister(ctx context.Context, in *WorkerReq, opts ...grpc.CallOption) (*WorkerResponse, error) {
	out := new(WorkerResponse)
	err := c.cc.Invoke(ctx, Workers_DeRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workersClient) GetRecentlyDeregistered(ctx context.Context, in *WorkersReq, opts ...grpc.CallOption) (*WorkersResp, error) {
	out := new(WorkersResp)
	err := c.cc.Invoke(ctx, Workers_GetRecentlyDeregistered_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkersServer is the server API for Workers service.
// All implementations must embed UnimplementedWorkersServer
// for forward compatibility
type WorkersServer interface {
	Finished(context.Context, *WorkerReq) (*WorkerResponse, error)
	BuildCommandsRun(context.Context, *CommandsRunReq) (*WorkerResponse, error)
	Register(context.Context, *WorkerRegReq) (*WorkerResponse, error)
	DeRegister(context.Context, *WorkerReq) (*WorkerResponse, error)
	GetRecentlyDeregistered(context.Context, *WorkersReq) (*WorkersResp, error)
	mustEmbedUnimplementedWorkersServer()
}

// UnimplementedWorkersServer must be embedded to have forward compatible implementations.
type UnimplementedWorkersServer struct {
}

func (UnimplementedWorkersServer) Finished(context.Context, *WorkerReq) (*WorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Finished not implemented")
}
func (UnimplementedWorkersServer) BuildCommandsRun(context.Context, *CommandsRunReq) (*WorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildCommandsRun not implemented")
}
func (UnimplementedWorkersServer) Register(context.Context, *WorkerRegReq) (*WorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedWorkersServer) DeRegister(context.Context, *WorkerReq) (*WorkerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeRegister not implemented")
}
func (UnimplementedWorkersServer) GetRecentlyDeregistered(context.Context, *WorkersReq) (*WorkersResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRecentlyDeregistered not implemented")
}
func (UnimplementedWorkersServer) mustEmbedUnimplementedWorkersServer() {}

// UnsafeWorkersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkersServer will
// result in compilation errors.
type UnsafeWorkersServer interface {
	mustEmbedUnimplementedWorkersServer()
}

func RegisterWorkersServer(s grpc.ServiceRegistrar, srv WorkersServer) {
	s.RegisterService(&Workers_ServiceDesc, srv)
}

func _Workers_Finished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkersServer).Finished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Workers_Finished_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkersServer).Finished(ctx, req.(*WorkerReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Workers_BuildCommandsRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandsRunReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkersServer).BuildCommandsRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Workers_BuildCommandsRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkersServer).BuildCommandsRun(ctx, req.(*CommandsRunReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Workers_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerRegReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkersServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Workers_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkersServer).Register(ctx, req.(*WorkerRegReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Workers_DeRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkersServer).DeRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Workers_DeRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkersServer).DeRegister(ctx, req.(*WorkerReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Workers_GetRecentlyDeregistered_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkersServer).GetRecentlyDeregistered(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Workers_GetRecentlyDeregistered_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkersServer).GetRecentlyDeregistered(ctx, req.(*WorkersReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Workers_ServiceDesc is the grpc.ServiceDesc for Workers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Workers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Workers",
	HandlerType: (*WorkersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Finished",
			Handler:    _Workers_Finished_Handler,
		},
		{
			MethodName: "BuildCommandsRun",
			Handler:    _Workers_BuildCommandsRun_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _Workers_Register_Handler,
		},
		{
			MethodName: "DeRegister",
			Handler:    _Workers_DeRegister_Handler,
		},
		{
			MethodName: "GetRecentlyDeregistered",
			Handler:    _Workers_GetRecentlyDeregistered_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/brisk-api.proto",
}

const (
	Supers_Finished_FullMethodName               = "/api.Supers/Finished"
	Supers_Register_FullMethodName               = "/api.Supers/Register"
	Supers_DeRegister_FullMethodName             = "/api.Supers/DeRegister"
	Supers_MarkSuperAsUnreachable_FullMethodName = "/api.Supers/MarkSuperAsUnreachable"
	Supers_RecordSetup_FullMethodName            = "/api.Supers/RecordSetup"
)

// SupersClient is the client API for Supers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SupersClient interface {
	Finished(ctx context.Context, in *SuperReq, opts ...grpc.CallOption) (*SuperResponse, error)
	Register(ctx context.Context, in *SuperRegReq, opts ...grpc.CallOption) (*SuperResponse, error)
	DeRegister(ctx context.Context, in *SuperReq, opts ...grpc.CallOption) (*SuperResponse, error)
	MarkSuperAsUnreachable(ctx context.Context, in *UnreacheableReq, opts ...grpc.CallOption) (*UnreachableResp, error)
	RecordSetup(ctx context.Context, in *SuperReq, opts ...grpc.CallOption) (*SuperResponse, error)
}

type supersClient struct {
	cc grpc.ClientConnInterface
}

func NewSupersClient(cc grpc.ClientConnInterface) SupersClient {
	return &supersClient{cc}
}

func (c *supersClient) Finished(ctx context.Context, in *SuperReq, opts ...grpc.CallOption) (*SuperResponse, error) {
	out := new(SuperResponse)
	err := c.cc.Invoke(ctx, Supers_Finished_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supersClient) Register(ctx context.Context, in *SuperRegReq, opts ...grpc.CallOption) (*SuperResponse, error) {
	out := new(SuperResponse)
	err := c.cc.Invoke(ctx, Supers_Register_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supersClient) DeRegister(ctx context.Context, in *SuperReq, opts ...grpc.CallOption) (*SuperResponse, error) {
	out := new(SuperResponse)
	err := c.cc.Invoke(ctx, Supers_DeRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supersClient) MarkSuperAsUnreachable(ctx context.Context, in *UnreacheableReq, opts ...grpc.CallOption) (*UnreachableResp, error) {
	out := new(UnreachableResp)
	err := c.cc.Invoke(ctx, Supers_MarkSuperAsUnreachable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supersClient) RecordSetup(ctx context.Context, in *SuperReq, opts ...grpc.CallOption) (*SuperResponse, error) {
	out := new(SuperResponse)
	err := c.cc.Invoke(ctx, Supers_RecordSetup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SupersServer is the server API for Supers service.
// All implementations must embed UnimplementedSupersServer
// for forward compatibility
type SupersServer interface {
	Finished(context.Context, *SuperReq) (*SuperResponse, error)
	Register(context.Context, *SuperRegReq) (*SuperResponse, error)
	DeRegister(context.Context, *SuperReq) (*SuperResponse, error)
	MarkSuperAsUnreachable(context.Context, *UnreacheableReq) (*UnreachableResp, error)
	RecordSetup(context.Context, *SuperReq) (*SuperResponse, error)
	mustEmbedUnimplementedSupersServer()
}

// UnimplementedSupersServer must be embedded to have forward compatible implementations.
type UnimplementedSupersServer struct {
}

func (UnimplementedSupersServer) Finished(context.Context, *SuperReq) (*SuperResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Finished not implemented")
}
func (UnimplementedSupersServer) Register(context.Context, *SuperRegReq) (*SuperResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedSupersServer) DeRegister(context.Context, *SuperReq) (*SuperResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeRegister not implemented")
}
func (UnimplementedSupersServer) MarkSuperAsUnreachable(context.Context, *UnreacheableReq) (*UnreachableResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkSuperAsUnreachable not implemented")
}
func (UnimplementedSupersServer) RecordSetup(context.Context, *SuperReq) (*SuperResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordSetup not implemented")
}
func (UnimplementedSupersServer) mustEmbedUnimplementedSupersServer() {}

// UnsafeSupersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SupersServer will
// result in compilation errors.
type UnsafeSupersServer interface {
	mustEmbedUnimplementedSupersServer()
}

func RegisterSupersServer(s grpc.ServiceRegistrar, srv SupersServer) {
	s.RegisterService(&Supers_ServiceDesc, srv)
}

func _Supers_Finished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuperReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupersServer).Finished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Supers_Finished_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupersServer).Finished(ctx, req.(*SuperReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supers_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuperRegReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupersServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Supers_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupersServer).Register(ctx, req.(*SuperRegReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supers_DeRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuperReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupersServer).DeRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Supers_DeRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupersServer).DeRegister(ctx, req.(*SuperReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supers_MarkSuperAsUnreachable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnreacheableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupersServer).MarkSuperAsUnreachable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Supers_MarkSuperAsUnreachable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupersServer).MarkSuperAsUnreachable(ctx, req.(*UnreacheableReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supers_RecordSetup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuperReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupersServer).RecordSetup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Supers_RecordSetup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupersServer).RecordSetup(ctx, req.(*SuperReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Supers_ServiceDesc is the grpc.ServiceDesc for Supers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Supers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Supers",
	HandlerType: (*SupersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Finished",
			Handler:    _Supers_Finished_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _Supers_Register_Handler,
		},
		{
			MethodName: "DeRegister",
			Handler:    _Supers_DeRegister_Handler,
		},
		{
			MethodName: "MarkSuperAsUnreachable",
			Handler:    _Supers_MarkSuperAsUnreachable_Handler,
		},
		{
			MethodName: "RecordSetup",
			Handler:    _Supers_RecordSetup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/brisk-api.proto",
}
