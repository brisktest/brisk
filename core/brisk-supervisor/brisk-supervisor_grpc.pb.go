// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.11
// source: brisk-supervisor/brisk-supervisor.proto

package brisk_supervisor

import (
	api "brisk-supervisor/api"
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BriskSupervisorClient is the client API for BriskSupervisor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BriskSupervisorClient interface {
	// Lock is used to lock the supervisor for the duration of the test run
	// we wrap RunTests because we want to sync before we run tests
	Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (BriskSupervisor_LockClient, error)
	RunTests(ctx context.Context, in *TestOption, opts ...grpc.CallOption) (BriskSupervisor_RunTestsClient, error)
	Setup(ctx context.Context, in *TestOption, opts ...grpc.CallOption) (*Response, error)
}

type briskSupervisorClient struct {
	cc grpc.ClientConnInterface
}

func NewBriskSupervisorClient(cc grpc.ClientConnInterface) BriskSupervisorClient {
	return &briskSupervisorClient{cc}
}

func (c *briskSupervisorClient) Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (BriskSupervisor_LockClient, error) {
	stream, err := c.cc.NewStream(ctx, &BriskSupervisor_ServiceDesc.Streams[0], "/brisksupervisor.BriskSupervisor/Lock", opts...)
	if err != nil {
		return nil, err
	}
	x := &briskSupervisorLockClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BriskSupervisor_LockClient interface {
	Recv() (*LockResponse, error)
	grpc.ClientStream
}

type briskSupervisorLockClient struct {
	grpc.ClientStream
}

func (x *briskSupervisorLockClient) Recv() (*LockResponse, error) {
	m := new(LockResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *briskSupervisorClient) RunTests(ctx context.Context, in *TestOption, opts ...grpc.CallOption) (BriskSupervisor_RunTestsClient, error) {
	stream, err := c.cc.NewStream(ctx, &BriskSupervisor_ServiceDesc.Streams[1], "/brisksupervisor.BriskSupervisor/RunTests", opts...)
	if err != nil {
		return nil, err
	}
	x := &briskSupervisorRunTestsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BriskSupervisor_RunTestsClient interface {
	Recv() (*Output, error)
	grpc.ClientStream
}

type briskSupervisorRunTestsClient struct {
	grpc.ClientStream
}

func (x *briskSupervisorRunTestsClient) Recv() (*Output, error) {
	m := new(Output)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *briskSupervisorClient) Setup(ctx context.Context, in *TestOption, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/brisksupervisor.BriskSupervisor/Setup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BriskSupervisorServer is the server API for BriskSupervisor service.
// All implementations must embed UnimplementedBriskSupervisorServer
// for forward compatibility
type BriskSupervisorServer interface {
	// Lock is used to lock the supervisor for the duration of the test run
	// we wrap RunTests because we want to sync before we run tests
	Lock(*LockRequest, BriskSupervisor_LockServer) error
	RunTests(*TestOption, BriskSupervisor_RunTestsServer) error
	Setup(context.Context, *TestOption) (*Response, error)
	mustEmbedUnimplementedBriskSupervisorServer()
}

// UnimplementedBriskSupervisorServer must be embedded to have forward compatible implementations.
type UnimplementedBriskSupervisorServer struct {
}

func (UnimplementedBriskSupervisorServer) Lock(*LockRequest, BriskSupervisor_LockServer) error {
	return status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedBriskSupervisorServer) RunTests(*TestOption, BriskSupervisor_RunTestsServer) error {
	return status.Errorf(codes.Unimplemented, "method RunTests not implemented")
}
func (UnimplementedBriskSupervisorServer) Setup(context.Context, *TestOption) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Setup not implemented")
}
func (UnimplementedBriskSupervisorServer) mustEmbedUnimplementedBriskSupervisorServer() {}

// UnsafeBriskSupervisorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BriskSupervisorServer will
// result in compilation errors.
type UnsafeBriskSupervisorServer interface {
	mustEmbedUnimplementedBriskSupervisorServer()
}

func RegisterBriskSupervisorServer(s grpc.ServiceRegistrar, srv BriskSupervisorServer) {
	s.RegisterService(&BriskSupervisor_ServiceDesc, srv)
}

func _BriskSupervisor_Lock_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LockRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BriskSupervisorServer).Lock(m, &briskSupervisorLockServer{stream})
}

type BriskSupervisor_LockServer interface {
	Send(*LockResponse) error
	grpc.ServerStream
}

type briskSupervisorLockServer struct {
	grpc.ServerStream
}

func (x *briskSupervisorLockServer) Send(m *LockResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BriskSupervisor_RunTests_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TestOption)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BriskSupervisorServer).RunTests(m, &briskSupervisorRunTestsServer{stream})
}

type BriskSupervisor_RunTestsServer interface {
	Send(*Output) error
	grpc.ServerStream
}

type briskSupervisorRunTestsServer struct {
	grpc.ServerStream
}

func (x *briskSupervisorRunTestsServer) Send(m *Output) error {
	return x.ServerStream.SendMsg(m)
}

func _BriskSupervisor_Setup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestOption)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BriskSupervisorServer).Setup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/brisksupervisor.BriskSupervisor/Setup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BriskSupervisorServer).Setup(ctx, req.(*TestOption))
	}
	return interceptor(ctx, in, info, handler)
}

// BriskSupervisor_ServiceDesc is the grpc.ServiceDesc for BriskSupervisor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BriskSupervisor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "brisksupervisor.BriskSupervisor",
	HandlerType: (*BriskSupervisorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Setup",
			Handler:    _BriskSupervisor_Setup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Lock",
			Handler:       _BriskSupervisor_Lock_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RunTests",
			Handler:       _BriskSupervisor_RunTests_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "brisk-supervisor/brisk-supervisor.proto",
}

// CommandRunnerClient is the client API for CommandRunner service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommandRunnerClient interface {
	RunCommands(ctx context.Context, opts ...grpc.CallOption) (CommandRunner_RunCommandsClient, error)
	Setup(ctx context.Context, in *TestOption, opts ...grpc.CallOption) (*Response, error)
	CheckBuild(ctx context.Context, in *CheckBuildMsg, opts ...grpc.CallOption) (*CheckBuildResp, error)
}

type commandRunnerClient struct {
	cc grpc.ClientConnInterface
}

func NewCommandRunnerClient(cc grpc.ClientConnInterface) CommandRunnerClient {
	return &commandRunnerClient{cc}
}

func (c *commandRunnerClient) RunCommands(ctx context.Context, opts ...grpc.CallOption) (CommandRunner_RunCommandsClient, error) {
	stream, err := c.cc.NewStream(ctx, &CommandRunner_ServiceDesc.Streams[0], "/brisksupervisor.CommandRunner/RunCommands", opts...)
	if err != nil {
		return nil, err
	}
	x := &commandRunnerRunCommandsClient{stream}
	return x, nil
}

type CommandRunner_RunCommandsClient interface {
	Send(*api.Command) error
	Recv() (*Output, error)
	grpc.ClientStream
}

type commandRunnerRunCommandsClient struct {
	grpc.ClientStream
}

func (x *commandRunnerRunCommandsClient) Send(m *api.Command) error {
	return x.ClientStream.SendMsg(m)
}

func (x *commandRunnerRunCommandsClient) Recv() (*Output, error) {
	m := new(Output)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commandRunnerClient) Setup(ctx context.Context, in *TestOption, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/brisksupervisor.CommandRunner/Setup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commandRunnerClient) CheckBuild(ctx context.Context, in *CheckBuildMsg, opts ...grpc.CallOption) (*CheckBuildResp, error) {
	out := new(CheckBuildResp)
	err := c.cc.Invoke(ctx, "/brisksupervisor.CommandRunner/CheckBuild", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandRunnerServer is the server API for CommandRunner service.
// All implementations must embed UnimplementedCommandRunnerServer
// for forward compatibility
type CommandRunnerServer interface {
	RunCommands(CommandRunner_RunCommandsServer) error
	Setup(context.Context, *TestOption) (*Response, error)
	CheckBuild(context.Context, *CheckBuildMsg) (*CheckBuildResp, error)
	mustEmbedUnimplementedCommandRunnerServer()
}

// UnimplementedCommandRunnerServer must be embedded to have forward compatible implementations.
type UnimplementedCommandRunnerServer struct {
}

func (UnimplementedCommandRunnerServer) RunCommands(CommandRunner_RunCommandsServer) error {
	return status.Errorf(codes.Unimplemented, "method RunCommands not implemented")
}
func (UnimplementedCommandRunnerServer) Setup(context.Context, *TestOption) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Setup not implemented")
}
func (UnimplementedCommandRunnerServer) CheckBuild(context.Context, *CheckBuildMsg) (*CheckBuildResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckBuild not implemented")
}
func (UnimplementedCommandRunnerServer) mustEmbedUnimplementedCommandRunnerServer() {}

// UnsafeCommandRunnerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommandRunnerServer will
// result in compilation errors.
type UnsafeCommandRunnerServer interface {
	mustEmbedUnimplementedCommandRunnerServer()
}

func RegisterCommandRunnerServer(s grpc.ServiceRegistrar, srv CommandRunnerServer) {
	s.RegisterService(&CommandRunner_ServiceDesc, srv)
}

func _CommandRunner_RunCommands_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommandRunnerServer).RunCommands(&commandRunnerRunCommandsServer{stream})
}

type CommandRunner_RunCommandsServer interface {
	Send(*Output) error
	Recv() (*api.Command, error)
	grpc.ServerStream
}

type commandRunnerRunCommandsServer struct {
	grpc.ServerStream
}

func (x *commandRunnerRunCommandsServer) Send(m *Output) error {
	return x.ServerStream.SendMsg(m)
}

func (x *commandRunnerRunCommandsServer) Recv() (*api.Command, error) {
	m := new(api.Command)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CommandRunner_Setup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestOption)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandRunnerServer).Setup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/brisksupervisor.CommandRunner/Setup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandRunnerServer).Setup(ctx, req.(*TestOption))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommandRunner_CheckBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBuildMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandRunnerServer).CheckBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/brisksupervisor.CommandRunner/CheckBuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandRunnerServer).CheckBuild(ctx, req.(*CheckBuildMsg))
	}
	return interceptor(ctx, in, info, handler)
}

// CommandRunner_ServiceDesc is the grpc.ServiceDesc for CommandRunner service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommandRunner_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "brisksupervisor.CommandRunner",
	HandlerType: (*CommandRunnerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Setup",
			Handler:    _CommandRunner_Setup_Handler,
		},
		{
			MethodName: "CheckBuild",
			Handler:    _CommandRunner_CheckBuild_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunCommands",
			Handler:       _CommandRunner_RunCommands_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "brisk-supervisor/brisk-supervisor.proto",
}
